Python `eval()` vs. `ast.literal_eval()` Notes

==================================================
Section 1: What is a Python Literal?
==================================================

Definition:
A literal is a notation for representing a fixed value in source code. In simple terms, it's the actual data itself, written directly in your code.

Examples:
- String: "hello", 'world'
- Number (Integer): 123, 42
- Number (Float): 3.14, 2.0
- List: [1, 2, "apple"]
- Dictionary: {"key": "value", "id": 1}
- Tuple: (1, 2, 3)
- Boolean: True, False
- NoneType: None

==================================================
Section 2: The `eval()` function
==================================================

What it is:
`eval()` is a built-in Python function that takes a string as an argument and executes it as a Python expression. It can run almost any piece of Python code.

Advantages:
- Extremely powerful and flexible. It can dynamically execute code constructed from strings.

Disadvantages (CRITICAL):
- MAJOR SECURITY RISK: This is the most important point. `eval()` will execute ANY code given to it. If you use `eval()` on user input, a malicious user can run commands to delete your files, steal data, or attack your system.
- Slower: It is generally slower than more specific functions because it has to go through the full Python parser and interpreter.

Example of misuse:
If your code is `eval(input())` and a user enters `__import__('os').system('dir')`, `eval()` will run that command.

==================================================
Section 3: The `ast.literal_eval()` function
==================================================

What it is:
`ast.literal_eval()` is a function from Python's `ast` (Abstract Syntax Trees) module. It safely evaluates a string that contains a Python literal.

Advantages:
- SAFE: This is its primary advantage. It ONLY evaluates the safe literals listed in Section 1. It will not execute functions, commands, or any other kind of expression. This prevents the security risks of `eval()`.
- Good for parsing data: It's an excellent tool for converting string representations of data (like from a config file or API response) into actual Python objects.

Disadvantages:
- Limited: It is much less flexible than `eval()`. It cannot perform calculations (e.g., it will fail on "1 + 1") or handle anything that isn't a literal. This is an intentional safety feature.

Example of safe usage:
```python
import ast

user_input = "[1, 2, {'key': 'value'}]"
try:
    my_list = ast.literal_eval(user_input)
    # my_list is now a real Python list: [1, 2, {'key': 'value'}]
except (ValueError, SyntaxError):
    print("Invalid literal input!")
```

==================================================
Section 4: More Examples and Comparisons
==================================================

Here is a side-by-side comparison of how each function handles different kinds of string inputs.

--------------------------------------------------
Input String: "'[10, 20, 30]'"
--------------------------------------------------
eval(input_str):
  - Result: [10, 20, 30] (A list object)
  - Comment: Works correctly.

ast.literal_eval(input_str):
  - Result: [10, 20, 30] (A list object)
  - Comment: Works correctly and safely. This is the ideal use case.

--------------------------------------------------
Input String: "'1 + 2'"
--------------------------------------------------
eval(input_str):
  - Result: 3 (An integer)
  - Comment: Correctly performs the addition.

ast.literal_eval(input_str):
  - Result: Raises a ValueError.
  - Comment: Fails safely because '+' is an operator, not a literal.

--------------------------------------------------
Input String: "'abs(-10)'"
--------------------------------------------------
eval(input_str):
  - Result: 10 (An integer)
  - Comment: Correctly calls the abs() function.

ast.literal_eval(input_str):
  - Result: Raises a ValueError.
  - Comment: Fails safely because it will not execute functions.

--------------------------------------------------
Input String: "'hello'"
--------------------------------------------------
eval(input_str):
  - Result: Raises a NameError (unless a variable named 'hello' exists).
  - Comment: Tries to evaluate 'hello' as a variable.

ast.literal_eval(input_str):
  - Result: 'hello' (A string object)
  - Comment: Correctly and safely interprets the input as a string literal.

--------------------------------------------------
Input String: "'__import__(\"os\").getcwd()'"
--------------------------------------------------
eval(input_str):
  - Result: Returns the current working directory (e.g., 'C:\\Users\\').
  - Comment: DANGEROUS. Executes the command.

ast.literal_eval(input_str):
  - Result: Raises a ValueError.
  - Comment: Fails safely, preventing the command from running.